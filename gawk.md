# GAWK(1)
Книга на русском:
Смотрите GAWK: Эффективное программирование на AWK для полного списка участников gawk и его документации.
mphttp://www.crossplatform.ru/documentation/awk/awk_bal_oglav.php

- [GAWK(1)](#gawk1)
  - [ИМЯ, ВЕРСИЯ](#имя-версия)
  - [СИНТАКСИС](#синтаксис)
  - [ОПИСАНИЕ](#описание)
  - [ФОРМАТ ПАРАМЕТРОВ](#формат-параметров)
  - [ПАРАМЕТРЫ](#параметры)
      - [`-f` файл-программы, `--file` файл-программы](#-f-файл-программы---file-файл-программы)
      - [`-F` fs, `--field-separator` fs](#-f-fs---field-separator-fs)
      - [`-v` var=val, `--assign` var=val](#-v-varval---assign-varval)
      - [`-b`, `--characters-as-bytes`](#-b---characters-as-bytes)
      - [`-c`, `--traditional`](#-c---traditional)
      - [`-C`, `--copyright`](#-c---copyright)
      - [`-d[file]`, `--dump-variables[=file]`](#-dfile---dump-variablesfile)
      - [`-D`\[file\], `--debug`\[=file\]](#-dfile---debugfile)
      - [`-e` текст-программы, `--source` текст-программы](#-e-текст-программы---source-текст-программы)
      - [`-E` файл, `--exec` файл](#-e-файл---exec-файл)
      - [`-g`, `--gen-pot`](#-g---gen-pot)
      - [`-h`, `--help`](#-h---help)
      - [`-i` файл-включения, `--include` файл-включения](#-i-файл-включения---include-файл-включения)
      - [`-l` lib, `--load` lib](#-l-lib---load-lib)
      - [`-L` \[значение\], `--lint`\[=значение\]](#-l-значение---lintзначение)
      - [`-M`, `--bignum`](#-m---bignum)
      - [`-n`, `--non-decimal-data`](#-n---non-decimal-data)
      - [`-N`, `--use-lc-numeric`](#-n---use-lc-numeric)
      - [`-o`\[файл\], `--pretty-print`\[=файл\]](#-oфайл---pretty-printфайл)
      - [`-O`,`--optimize`](#-o--optimize)
      - [`-p`\[файл-профиля\], `--profile`\[=файл-профиля\]](#-pфайл-профиля---profileфайл-профиля)
      - [`-P`, `--posix`](#-p---posix)
      - [`-r`, `--re-interval`](#-r---re-interval)
      - [`-s`, `--no-optimize`](#-s---no-optimize)
      - [`-S`, `--sandbox`](#-s---sandbox)
      - [`-t`, `--lint-old`](#-t---lint-old)
      - [`-V`, `--version`](#-v---version)
      - [`--`](#--)
  - [ВЫПОЛНЕНИЕ ПРОГРАММ AWK](#выполнение-программ-awk)
    - [Командные строки](#командные-строки)
  - [ПЕРЕМЕННЫЕ, ЗАПИСИ И ПОЛЯ](#переменные-записи-и-поля)
    - [Записи](#записи)
    - [Поля](#поля)
    - [Встроенные переменные](#встроенные-переменные)
      - [`ARGC`](#argc)
      - [`ARGIND`](#argind)
      - [`ARGV`](#argv)
      - [`BINMODE`](#binmode)
      - [`CONVFMT`](#convfmt)
      - [`ENVIRON`](#environ)
      - [`ERRNO`](#errno)
      - [`FIELDWIDTHS`](#fieldwidths)
      - [`FILENAME`](#filename)
      - [`FNR`](#fnr)
      - [`FPAT`](#fpat)
      - [`FS`](#fs)
      - [`FUNCTAB`](#functab)
      - [`IGNORECASE`](#ignorecase)
      - [`LINT`](#lint)
      - [`NF`](#nf)
      - [`NR`](#nr)
      - [`OFMT`](#ofmt)
      - [`OFS`](#ofs)
      - [`ORS`](#ors)
      - [`PREC`](#prec)
      - [`PROCINFO`](#procinfo)
        - [`PROCINFO`\["argv"\]     Аргументы командной строки, полученные gawk на уровне языка C. Индексы начинаются с нуля.](#procinfoargv-----аргументы-командной-строки-полученные-gawk-на-уровне-языка-c-индексы-начинаются-с-нуля)
        - [`PROCINFO`\["egid"\]     Значение системного вызова getegid(2).](#procinfoegid-----значение-системного-вызова-getegid2)
        - [`PROCINFO`\["errno"\]    Значение errno(3), когда ERRNO установлено в соответствующее сообщение об ошибке.](#procinfoerrno----значение-errno3-когда-errno-установлено-в-соответствующее-сообщение-об-ошибке)
        - [`PROCINFO`\["euid"\]     Значение системного вызова geteuid(2).](#procinfoeuid-----значение-системного-вызова-geteuid2)
        - [`PROCINFO`\["gid"\]      Значение системного вызова getgid(2).](#procinfogid------значение-системного-вызова-getgid2)
        - [`PROCINFO`\["identifiers"\] Подмассив, индексируемый именами всех идентификаторов, используемых в тексте программы AWK.](#procinfoidentifiers-подмассив-индексируемый-именами-всех-идентификаторов-используемых-в-тексте-программы-awk)
        - [`PROCINFO`\["pgrpid"\]    Идентификатор группы процессов текущего процесса.](#procinfopgrpid----идентификатор-группы-процессов-текущего-процесса)
        - [`PROCINFO`\["pid"\]       Идентификатор текущего процесса.](#procinfopid-------идентификатор-текущего-процесса)
        - [`PROCINFO`\["ppid"\]      Идентификатор родительского процесса текущего процесса.](#procinfoppid------идентификатор-родительского-процесса-текущего-процесса)
        - [`PROCINFO`\["strftime"\]  Строка формата времени по умолчанию для strftime().](#procinfostrftime--строка-формата-времени-по-умолчанию-для-strftime)
        - [`PROCINFO`\["uid"\]       Значение системного вызова getuid(2).](#procinfouid-------значение-системного-вызова-getuid2)
        - [Значения следующих элементов присутствуют, если доступна загрузка динамических расширений:](#значения-следующих-элементов-присутствуют-если-доступна-загрузка-динамических-расширений)
          - [`PROCINFO`\["api\_major"\]  Основная версия API расширения.](#procinfoapi_major--основная-версия-api-расширения)
          - [`PROCINFO`\["api\_minor"\]  Второстепенная версия API расширения.](#procinfoapi_minor--второстепенная-версия-api-расширения)
        - [Следующие элементы доступны, если поддержка MPFR скомпилирована в gawk:](#следующие-элементы-доступны-если-поддержка-mpfr-скомпилирована-в-gawk)
          - [`PROCINFO`\["gmp\_version"\]  Версия библиотеки GNU MP, используемой для поддержки чисел с произвольной точностью в gawk.](#procinfogmp_version--версия-библиотеки-gnu-mp-используемой-для-поддержки-чисел-с-произвольной-точностью-в-gawk)
          - [`PROCINFO`\["mpfr\_version"\]  Версия библиотеки GNU MPFR, используемой для поддержки чисел с произвольной точностью в gawk.](#procinfompfr_version--версия-библиотеки-gnu-mpfr-используемой-для-поддержки-чисел-с-произвольной-точностью-в-gawk)
          - [`PROCINFO`\["prec\_max"\]  Максимальная поддерживаемая точность библиотекой GNU MPFR для чисел с произвольной точностью.](#procinfoprec_max--максимальная-поддерживаемая-точность-библиотекой-gnu-mpfr-для-чисел-с-произвольной-точностью)
          - [`PROCINFO`\["prec\_min"\]  Минимальная допустимая точность библиотекой GNU MPFR для чисел с произвольной точностью.](#procinfoprec_min--минимальная-допустимая-точность-библиотекой-gnu-mpfr-для-чисел-с-произвольной-точностью)
        - [Следующие элементы могут быть установлены программой для изменения поведения gawk:](#следующие-элементы-могут-быть-установлены-программой-для-изменения-поведения-gawk)
          - [`PROCINFO`\["NONFATAL"\]  Если это существует, то ошибки ввода-вывода для всех перенаправлений становятся нефатальными.](#procinfononfatal--если-это-существует-то-ошибки-ввода-вывода-для-всех-перенаправлений-становятся-нефатальными)
          - [`PROCINFO`\["ame", "NONFATAL"\]  Делает ошибки ввода-вывода для имени нефатальными.](#procinfoame-nonfatal--делает-ошибки-ввода-вывода-для-имени-нефатальными)
          - [`PROCINFO`\["command", "pty"\]  Использует псевдотерминал для двусторонней связи с командой вместо настройки двух однонаправленных труб.](#procinfocommand-pty--использует-псевдотерминал-для-двусторонней-связи-с-командой-вместо-настройки-двух-однонаправленных-труб)
          - [`PROCINFO`\["input", "READ\_TIMEOUT"\] Таймаут в миллисекундах для чтения данных из ввода](#procinfoinput-read_timeout-таймаут-в-миллисекундах-для-чтения-данных-из-ввода)
          - [`PROCINFO`\["input", "RETRY"\]](#procinfoinput-retry)
          - [`PROCINFO`\["sorted\_in"\]](#procinfosorted_in)
      - [`ROUNDMODE`  Режим округления, используемый для арифметики произвольной точности для чисел](#roundmode--режим-округления-используемый-для-арифметики-произвольной-точности-для-чисел)
      - [`RS`  Разделитель записей ввода, по умолчанию символ новой строки.](#rs--разделитель-записей-ввода-по-умолчанию-символ-новой-строки)
      - [`RT`  Завершитель записи. Gawk устанавливает RT в текст ввода, который соответствует символу или регулярному выражению, указанному RS.](#rt--завершитель-записи-gawk-устанавливает-rt-в-текст-ввода-который-соответствует-символу-или-регулярному-выражению-указанному-rs)
      - [`RSTART`  Индекс первого символа, совпавшего с match(); 0, если совпадения нет. ( Это подразумевает, что индексы символов начинаются с единицы. )](#rstart--индекс-первого-символа-совпавшего-с-match-0-если-совпадения-нет--это-подразумевает-что-индексы-символов-начинаются-с-единицы-)
      - [`RLENGTH`  Длина строки, совпавшей с match(); -1, если совпадения нет.](#rlength--длина-строки-совпавшей-с-match--1-если-совпадения-нет)
      - [`SUBSEP`  Символ, используемый для разделения нескольких индексов в элементах массива, по умолчанию "\\034".](#subsep--символ-используемый-для-разделения-нескольких-индексов-в-элементах-массива-по-умолчанию-034)
      - [`SYMTAB`  Массив, индексы которого являются именами всех текущих глобальных переменных и массивов в программе.](#symtab--массив-индексы-которого-являются-именами-всех-текущих-глобальных-переменных-и-массивов-в-программе)
      - [`TEXTDOMAIN`  Текстовый домен программы AWK; используется для поиска локализованных переводов строк программы.](#textdomain--текстовый-домен-программы-awk-используется-для-поиска-локализованных-переводов-строк-программы)
    - [Массивы](#массивы)
    - [Типизация переменных и преобразование](#типизация-переменных-и-преобразование)
    - [Восьмеричные и шестнадцатеричные константы](#восьмеричные-и-шестнадцатеричные-константы)
    - [Строковые константы](#строковые-константы)
    - [Константы регулярных выражений](#константы-регулярных-выражений)
  - [ШАБЛОНЫ И ДЕЙСТВИЯ](#шаблоны-и-действия)
    - [Шаблоны](#шаблоны)
    - [Регулярные выражения](#регулярные-выражения)
      - [Escape-последовательности (Escape Sequences)](#escape-последовательности-escape-sequences)
      - [Классы символов (Character Classes)](#классы-символов-character-classes)
      - [Символ сортировки (Collating Symbols)](#символ-сортировки-collating-symbols)
      - [Класс эквивалентности (Equivalence Classes)](#класс-эквивалентности-equivalence-classes)
    - [Действия (Actions)](#действия-actions)
    - [Операторы (Operators)](#операторы-operators)
    - [Управляющие конструкции (Control Statements)](#управляющие-конструкции-control-statements)
    - [Операторы ввода/вывода (I/O Statements)](#операторы-вводавывода-io-statements)
    - [Оператор printf](#оператор-printf)
    - [Специальные имена файлов](#специальные-имена-файлов)
    - [Числовые функции](#числовые-функции)
    - [Строковые функции](#строковые-функции)
    - [Функции времени](#функции-времени)
      - [`mktime(datespec [, utc-flag])`](#mktimedatespec--utc-flag)
      - [`strftime([format [, timestamp[, utc-flag]]])`](#strftimeformat--timestamp-utc-flag)
      - [`systime()`](#systime)
    - [Функции манипуляции битами](#функции-манипуляции-битами)
    - [Функции типов](#функции-типов)
    - [Функции интернационализации](#функции-интернационализации)
    - [ПОЛЬЗОВАТЕЛЬСКИЕ ФУНКЦИИ](#пользовательские-функции)
  - [ДИНАМИЧЕСКАЯ ЗАГРУЗКА НОВЫХ ФУНКЦИЙ](#динамическая-загрузка-новых-функций)
  - [СИГНАЛЫ](#сигналы)
  - [МЕЖДУНАРОДНАЯ АДАПТАЦИЯ](#международная-адаптация)
  - [СОВМЕСТИМОСТЬ С POSIX](#совместимость-с-posix)
  - [ИСТОРИЧЕСКИЕ ОСОБЕННОСТИ](#исторические-особенности)
  - [РАСШИРЕНИЯ GNU](#расширения-gnu)
  - [ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ](#переменные-окружения)
  - [СТАТУС ВЫХОДА (Exit Code)](#статус-выхода-exit-code)
  - [ОТЧЕТЫ ОБ ОШИБКАХ](#отчеты-об-ошибках)
  - [ОШИБКИ](#ошибки)
  - [СМОТРИТЕ ТАКЖЕ](#смотрите-также)
  - [ПРИМЕРЫ](#примеры)

## ИМЯ, ВЕРСИЯ
gawk - язык обработки и сканирования шаблонов
Эта страница руководства документирует gawk, версия 4.2.

## СИНТАКСИС
gawk [ параметры в стиле POSIX или GNU ] -f файл-программы [ -- ] файл ...
gawk [ параметры в стиле POSIX или GNU ] [ -- ] текст-программы файл ...

## ОПИСАНИЕ
Gawk - это реализация языка AWK от проекта GNU. Он соответствует определению языка в стандарте POSIX 1003.1. Эта версия, в свою очередь, основана на описании в книге "Язык программирования AWK" авторов Ахо, Кернигана и Вайнбергера. Gawk предоставляет дополнительные функции, найденные в текущей версии awk Брайана Кернигана и многочисленные расширения, специфичные для GNU.

Командная строка состоит из параметров для самого gawk, текста программы AWK ( если он не предоставлен через параметры -f или -i ) и значений, которые будут доступны в предопределённых переменных AWK ARGC и ARGV.

Когда gawk вызывается с параметром --profile, он начинает собирать статистику профилирования во время выполнения программы. Gawk работает медленнее в этом режиме и автоматически создаёт профиль выполнения в файле awkprof.out по завершении. См. параметр --profile ниже.

Gawk также имеет встроенный отладчик. Интерактивная сессия отладки может быть начата, если указать параметр --debug в командной строке. В этом режиме выполнения gawk загружает исходный код AWK и затем запрашивает команды отладки. Gawk может отлаживать только исходный код программы AWK, предоставленный с параметром -f. Отладчик документирован в GAWK: Эффективное программирование на AWK.

## ФОРМАТ ПАРАМЕТРОВ
Параметры gawk могут быть либо традиционными однобуквенными параметрами в стиле POSIX, либо длинными параметрами в стиле GNU. Параметры POSIX начинаются с одного "–", в то время как длинные параметры начинаются с "--". Длинные параметры предоставляются как для функций, специфичных для GNU, так и для функций, предписанных POSIX.

Параметры, специфичные для gawk, обычно используются в форме длинного параметра. Аргументы длинных параметров либо соединяются с параметром знаком "=", без промежуточных пробелов, либо могут быть предоставлены в следующем аргументе командной строки. Длинные параметры могут быть сокращены, при условии, что сокращение остаётся уникальным.

Кроме того, у каждого длинного параметра есть соответствующий короткий параметр, так что функциональность параметра может быть использована в исполняемых скриптах #!.

## ПАРАМЕТРЫ
Gawk принимает следующие параметры. Стандартные параметры перечислены первыми, за ними следуют параметры для расширений gawk, перечисленные в алфавитном порядке по короткому параметру.

#### `-f` файл-программы, `--file` файл-программы
Чтение исходного кода программы AWK из файла файл-программы, вместо первого аргумента командной строки. Можно использовать несколько параметров -f ( или --file ).

#### `-F` fs, `--field-separator` fs
Использовать fs в качестве разделителя полей ввода ( значение предопределённой переменной FS ).

#### `-v` var=val, `--assign` var=val
Присвоить значение val переменной var перед началом выполнения программы. Такие значения переменных доступны в правиле BEGIN программы AWK.

#### `-b`, `--characters-as-bytes`
Обрабатывать все входные данные как однобайтовые символы. Другими словами, не обращать внимания на информацию о локали при попытке обработать строки как многобайтовые символы. Параметр --posix отменяет этот.

#### `-c`, `--traditional`
Работать в режиме совместимости. В режиме совместимости gawk ведёт себя идентично awk Брайана Кернигана; ни одно из расширений, специфичных для GNU, не распознаётся. См. GNU EXTENSIONS ниже.

#### `-C`, `--copyright`
Печатает краткую версию сообщения о авторских правах GNU на стандартный вывод и успешно завершает работу.

#### `-d[file]`, `--dump-variables[=file]`
Печатает отсортированный список глобальных переменных, их типов и конечных значений в файл. Если файл не указан, gawk использует файл с именем awkvars.out в текущем каталоге.

Наличие списка всех глобальных переменных - хороший способ поиска опечаток в ваших программах. Вы также используете этот параметр, если у вас есть большая программа с множеством функций, и вы хотите убедиться, что ваши функции не используют глобальные переменные, которые вы имели в виду как локальные. ( Это особенно легко сделать с простыми именами переменных, такими как i, j и т.д. )

#### `-D`[file], `--debug`[=file]
Включить отладку программ AWK. По умолчанию отладчик читает команды интерактивно с клавиатуры ( стандартный ввод ). Необязательный аргумент файла указывает файл со списком команд, которые отладчик должен выполнить не интерактивно.

#### `-e` текст-программы, `--source` текст-программы
Использовать текст-программы в качестве исходного кода программы AWK. Этот параметр позволяет легко смешивать библиотечные функции ( используемые через параметры -f и -i ) с исходным кодом, введённым в командной строке. Он предназначен в первую очередь для средних и больших программ AWK, используемых в оболочках.

#### `-E` файл, `--exec` файл
Похоже на -f, однако этот параметр обрабатывается последним. Это следует использовать с #! скриптами, особенно для CGI приложений, чтобы избежать передачи параметров или исходного кода ( ! ) в командной строке из URL. Этот параметр отключает присвоение переменных командной строки.

#### `-g`, `--gen-pot`
Сканировать и анализировать программу AWK и генерировать файл формата GNU .pot ( Portable Object Template ) на стандартный вывод с записями для всех локализуемых строк в программе. Программа сама не выполняется. См. распределение GNU gettext для получения дополнительной информации о .pot файлах.

#### `-h`, `--help`
Печатает относительно краткое резюме доступных параметров на стандартный вывод. ( Согласно стандартам кодирования GNU, эти параметры вызывают немедленный успешный выход. )

#### `-i` файл-включения, `--include` файл-включения
Загружает библиотеку исходного кода awk. Это ищет библиотеку, используя переменную окружения AWKPATH. Если первоначальный поиск не удался, будет сделана ещё одна попытка после добавления суффикса .awk. Файл будет загружен только один раз ( т.е. дубликаты исключаются ), и код не составляет основной исходный код программы.

#### `-l` lib, `--load` lib
Загружает расширение gawk из общей библиотеки lib. Это ищет библиотеку, используя переменную окружения AWKLIBPATH. Если первоначальный поиск не удался, будет сделана ещё одна попытка после добавления суффикса общей библиотеки по умолчанию для платформы. Ожидается, что процедура инициализации библиотеки будет называться dl_load().

#### `-L` [значение], `--lint`[=значение]
Предоставляет предупреждения о конструкциях, которые сомнительны или не портируемы в другие реализации AWK. С необязательным аргументом fatal предупреждения lint становятся фатальными ошибками. Это может быть радикально, но его использование, безусловно, побудит разработку более чистых программ AWK. С необязательным аргументом invalid выдаются только предупреждения о действительно недопустимых конструкциях. ( Это ещё не полностью реализовано. )

#### `-M`, `--bignum`
Принудительно использовать произвольную точность арифметики для чисел. Этот параметр не имеет эффекта, если gawk не скомпилирован для использования библиотек GNU MPFR и MP. ( В этом случае gawk выдаёт предупреждение. )

#### `-n`, `--non-decimal-data`
Признавать восьмеричные и шестнадцатеричные значения во входных данных. Используйте этот параметр с большой осторожностью!

#### `-N`, `--use-lc-numeric`
Принудительно заставить gawk использовать символ десятичной точки локали при разборе входных данных. Хотя стандарт POSIX требует этого поведения, и gawk делает это, когда --posix включён, по умолчанию он следует традиционному поведению и использует точку в качестве десятичной точки, даже в локалях, где точка не является символом десятичной точки. Этот параметр отменяет поведение по умолчанию, без полной строгой строгости параметра --posix.

#### `-o`[файл], `--pretty-print`[=файл]
Выводит красиво отформатированную версию программы в файл. Если файл не указан, gawk использует файл с именем awkprof.out в текущем каталоге. Подразумевает --no-optimize.

#### `-O`,`--optimize`
Включает оптимизации по умолчанию gawk для внутреннего представления программы. В настоящее время это включает простое свёртывание констант и устранение хвостовых вызовов для рекурсивных функций. Этот параметр включён по умолчанию.

#### `-p`[файл-профиля], `--profile`[=файл-профиля]
Начинает сессию профилирования и отправляет данные профилирования в файл профиля. По умолчанию это awkprof.out. Профиль содержит количество выполнений каждого оператора в программе в левом поле и количество вызовов функций для каждой пользовательской функции. Подразумевает --no-optimize.

#### `-P`, `--posix`
Это включает режим совместимости, с следующими дополнительными ограничениями:
- \x escape последовательности не распознаются.
- Вы не можете продолжать строки после ? и :.
- Синоним func для ключевого слова function не распознаётся.
- Операторы ** и **= не могут использоваться вместо ^ и ^=.

#### `-r`, `--re-interval`
Включает использование интервалов в регулярных выражениях ( см. Регулярные выражения ниже ). Интервальные выражения традиционно не были доступны в языке AWK. Стандарт POSIX добавил их, чтобы сделать awk и egrep согласованными друг с другом. Они включены по умолчанию, но этот параметр остаётся для использования с --traditional.

#### `-s`, `--no-optimize`
Отключает оптимизации по умолчанию gawk для внутреннего представления программы.

#### `-S`, `--sandbox`
Запускает gawk в режиме песочницы, отключая функцию system(), перенаправление ввода с помощью getline, перенаправление вывода с помощью print и printf, и загрузку динамических расширений. Выполнение команд ( через конвейеры ) также отключено. Это эффективно блокирует скрипт от доступа к локальным ресурсам, кроме файлов, указанных в командной строке.

#### `-t`, `--lint-old`
Предоставляет предупреждения о конструкциях, которые не портируемы в оригинальную версию UNIX awk.

#### `-V`, `--version`
Печатает информацию о версии для этой конкретной копии gawk на стандартный вывод. Это полезно в основном для того, чтобы знать, актуальна ли текущая копия gawk на вашей системе по сравнению с тем, что распространяет Фонд свободного программного обеспечения. Это также полезно при сообщении об ошибках. ( Согласно стандартам кодирования GNU, эти параметры вызывают немедленный успешный выход. )

#### `--`
Указывает конец параметров. Это полезно, чтобы позволить дальнейшим аргументам программы AWK начинаться с "–". Это обеспечивает согласованность с конвенцией разбора аргументов, исползуемой большинством других программ POSIX.

В режиме совместимости любые другие параметры помечаются как недопустимые, но в остальном игнорируются. В нормальной работе, пока текст программы был предоставлен, неизвестные параметры передаются в программу AWK в массиве ARGV для обработки. Это особенно полезно для запуска программ AWK через механизм исполняемого интерпретатора #!.

Для совместимости с POSIX параметр -W может быть использован с именем длинного параметра.

## ВЫПОЛНЕНИЕ ПРОГРАММ AWK
Программа AWK состоит из последовательности необязательных директив, операторов-шаблонов и действий, а также необязательных определений функций.
```awk
@include "имя_файла"
@load "имя_файла"
шаблон   { операторы действий }
функция имя(список_параметров) { операторы }
```
Gawk сначала читает исходный код программы из файлов программы, если они указаны, из аргументов к --source или из первого не параметра аргумента в командной строке. Параметры -f и --source могут использоваться несколько раз в командной строке. Gawk читает текст программы так, как если бы все файлы программы и тексты исходного кода командной строки были объединены вместе. Это полезно для создания библиотек функций AWK, не включая их в каждую новую программу AWK, которая их использует. Это также предоставляет возможность смешивать библиотечные функции с программами командной строки.

Кроме того, строки, начинающиеся с @include, могут использоваться для включения других исходных файлов в вашу программу, что делает использование библиотек ещё проще. Это эквивалентно использованию параметра -i.

Строки, начинающиеся с @load, могут использоваться для загрузки функций расширения в вашу программу. Это эквивалентно использованию параметра -l.

Переменная окружения AWKPATH указывает путь поиска, который будет использоваться при поиске исходных файлов, названных с помощью параметров -f и -i. Если эта переменная не существует, путь по умолчанию - ".:/usr/local/share/awk". ( Фактический каталог может варьироваться в зависимости от того, как gawk был собран и установлен. ) Если имя файла, указанное в параметре -f, содержит символ "/", поиск по пути не выполняется.

Переменная окружения AWKLIBPATH указывает путь поиска, который будет использоваться при поиске исходных файлов, названных с помощью параметров -l. Если эта переменная не существует, путь по умолчанию - "/usr/local/lib/gawk". ( Фактический каталог может варьироваться в зависимости от того, как gawk был собран и установлен. )

Gawk выполняет программы AWK в следующем порядке. Сначала выполняются все присвоения переменных, указанные через параметр -v. Затем gawk компилирует программу в внутреннюю форму. Затем gawk выполняет код в правилах BEGIN ( если таковые имеются ), а затем начинает читать каждый файл, указанный в массиве ARGV ( до ARGV[ARGC-1] ). Если на командной строке не указано файлов, gawk читает стандартный ввод.

Если имя файла в командной строке имеет форму var=val, оно обрабатывается как присвоение переменной. Переменной var будет присвоено значение val. ( Это происходит после выполнения любых правил BEGIN. ) Присвоение переменной командной строки наиболее полезно для динамического присвоения значений переменным, которые AWK использует для управления тем, как входные данные разбиваются на поля и записи. Это также полезно для управления состоянием, если требуется несколько проходов по одному и тому же файлу данных.

Если значение определённого элемента ARGV пусто (""), gawk пропускает его.

Для каждого входного файла, если существует правило BEGINFILE, gawk выполняет связанный код перед обработкой содержимого файла. Аналогично, gawk выполняет код, связанный с ENDFILE, после обработки файла.

Для каждой записи во входных данных gawk проверяет, соответствует ли она любому шаблону в программе AWK. Для каждого шаблона, которому соответствует запись, gawk выполняет связанное действие. Шаблоны проверяются в порядке их появления в программе.

Наконец, после того как все входные данные исчерпаны, gawk выполняет код в правилах END ( если таковые имеются ).

### Командные строки
Согласно POSIX, файлы, указанные в командной строке awk, должны быть текстовыми файлами. Поведение "неопределено", если это не так. Большинство версий awk рассматривают каталог в командной строке как фатальную ошибку.

Начиная с версии 4.0 gawk, каталог в командной строке вызывает предупреждение, но в остальном пропускается. Если указан любой из параметров --posix или --traditional, gawk возвращается к тому, чтобы рассматривать каталоги в командной строке как фатальную ошибку.

## ПЕРЕМЕННЫЕ, ЗАПИСИ И ПОЛЯ
Переменные AWK динамичны; они появляются, когда их впервые используют. Их значения могут быть либо числами с плавающей запятой, либо строками, либо тем и другим, в зависимости от того, как они используются. Кроме того, gawk позволяет переменным иметь тип регулярного выражения. AWK также имеет одномерные массивы; массивы с несколькими измерениями могут быть смоделированы. Gawk предоставляет истинные массивы массивов; см. Массивы ниже. Несколько предопределённых переменных устанавливаются по мере выполнения программы; они описаны по мере необходимости и кратко изложены ниже.

### Записи
Обычно записи разделяются символами новой строки. Вы можете контролировать, как записи разделяются, присваивая значения встроенной переменной RS. Если RS - это любой одиночный символ, этот символ разделяет записи. В противном случае RS - это регулярное выражение. Текст во входных данных, который соответствует этому регулярному выражению, разделяет запись. Однако в режиме совместимости используется только первый символ его строкового значения для разделения записей. Если RS установлен в пустую строку, записи разделяются пустыми строками. Когда RS установлен в пустую строку, символ новой строки всегда действует как разделитель полей, в дополнение к любому значению, которое может иметь FS.

### Поля
При чтении каждой входной записи gawk разбивает запись на поля, используя значение переменной FS в качестве разделителя полей. Если FS - это одиночный символ, поля разделяются этим символом. Если FS - это пустая строка, то каждый отдельный символ становится отдельным полем. В противном случае FS ожидается как полное регулярное выражение. В специальном случае, если FS - это один пробел, поля разделяются последовательностями пробелов и/или табуляций и/или новых строк. ПРИМЕЧАНИЕ: Значение IGNORECASE ( см. ниже ) также влияет на то, как поля разбиваются, когда FS является регулярным выражением, и как записи разделяются, когда RS является регулярным выражением.

Если переменная FIELDWIDTHS установлена в список чисел, разделённых пробелами, каждое поле ожидается с фиксированной шириной, и gawk разбивает запись, используя указанные ширины. Каждая ширина поля может быть предварена значением, разделённым двоеточием, указывающим количество символов, которые нужно пропустить перед началом поля. Значение FS игнорируется. Присвоение нового значения FS или FPAT отменяет использование FIELDWIDTHS.

Аналогично, если переменная FPAT установлена в строку, представляющую регулярное выражение, каждое поле состоит из текста, который соответствует этому регулярному выражению. В этом случае регулярное выражение описывает сами поля, а не текст, который разделяет поля. Присвоение нового значения FS или FIELDWIDTHS отменяет использование FPAT.

Каждое поле во входной записи может быть указано по его позиции: $1, $2 и так далее. $0 - это вся запись. Поля не обязательно должны указываться константами:

        n = 5
        print $n

печатает пятое поле во входной записи.

Переменная NF устанавливается в общее количество полей во входной записи.

Ссылки на несуществующие поля ( т.е. поля после $NF ) создают пустую строку. Однако присвоение несуществующему полю ( например, $ ( NF+2 ) = 5 ) увеличивает значение NF, создаёт любые промежуточные поля с пустой строкой в качестве их значений и вызывает пересчёт значения $0, при этом поля разделяются значением OFS. Ссылки на поля с отрицательными номерами вызывают фатальную ошибку. Уменьшение NF приводит к потере значений полей, превышающих новое значение, и к пересчёту значения $0, при этом поля разделяются значением OFS.

Присвоение значения существующему полю вызывает полное восстановление записи, когда $0 ссылается. Аналогично, присвоение значения $0 вызывает повторное разделение записи, создавая новые значения для полей.

### Встроенные переменные
Встроенные переменные gawk:

#### `ARGC`
Количество аргументов командной строки ( не включает параметры для gawk или исходный код программы ).

#### `ARGIND`
Индекс в ARGV текущего обрабатываемого файла.

#### `ARGV`
Массив аргументов командной строки. Массив индексируется от 0 до ARGC - 1. Динамическое изменение содержимого ARGV может контролировать файлы, используемые для данных.

#### `BINMODE`
В не-POSIX системах указывает использование "двойного" режима для всех операций ввода-вывода. Числовые значения 1, 2 или 3 указывают, что входные файлы, выходные файлы или все файлы соответственно должны использовать двоичный ввод-вывод. Строковые значения "r" или "w" указывают, что входные файлы или выходные файлы соответственно должны использовать двоичный ввод-вывод. Строковые значения "rw" или "wr" указывают, что все файлы должны использовать двоичный ввод-вывод. Любое другое строковое значение рассматривается как "rw", но вызывает предупреждение.

#### `CONVFMT`
Формат преобразования для чисел, по умолчанию "%.6g".

#### `ENVIRON`
Массив, содержащий значения текущей среды. Массив индексируется по переменным окружения, каждый элемент является значением этой переменной ( например, ENVIRON["HOME"] может быть "/home/arnold" ).<br/>
В режиме POSIX изменение этого массива не влияет на среду, видимую программами, которые gawk запускает через перенаправление или функцию system(). В противном случае gawk обновляет свою реальную среду, так что программы, которые он запускает, видят изменения.

#### `ERRNO`
Если возникает системная ошибка либо при перенаправлении для getline, либо во время чтения для getline, либо при close(), то ERRNO устанавливается в строку, описывающую ошибку. Значение подлежит переводу в неанглийских локалях. Если строка в ERRNO соответствует системной ошибке в переменной errno(3), то числовое значение можно найти в PROCINFO["errno"]. Для не системных ошибок PROCINFO["errno"] будет равно нулю.

#### `FIELDWIDTHS`
Список ширин полей, разделённых пробелами. Когда установлено, gawk разбивает ввод на поля фиксированной ширины, вместо использования значения переменной FS в качестве разделителя полей. Каждая ширина поля может быть предварена значением, разделённым двоеточием, указывающим количество символов, которые нужно пропустить перед началом поля. См. Поля выше.

#### `FILENAME`
Имя текущего входного файла. Если файлы не указаны в командной строке, значение FILENAME равно "-". Однако FILENAME не определён внутри правила BEGIN ( если не установлен с помощью getline ).

#### `FNR`
Номер записи ввода в текущем входном файле.

#### `FPAT`
Регулярное выражение, описывающее содержимое полей в записи. Когда установлено, gawk разбивает ввод на поля, где поля соответствуют регулярному выражению, вместо использования значения переменной FS в качестве разделителя полей. См. Поля выше.

#### `FS`
Разделитель полей ввода, по умолчанию пробел. См. Поля выше.

#### `FUNCTAB`
Массив, индексы и соответствующие значения которого являются именами всех пользовательских или расширенных функций в программе. ПРИМЕЧАНИЕ: Вы не можете использовать оператор delete с массивом FUNCTAB.

#### `IGNORECASE`
Управляет чувствительностью к регистру всех операций с регулярными выражениями и строками. Если IGNORECASE имеет ненулевое значение, то сравнения строк и сопоставление шаблонов в правилах, разделение полей с FS и FPAT, разделение записей с RS, сопоставление регулярных выражений с ~ и !~, а также встроенные функции gensub(), gsub(), index(), match(), patsplit(), split() и sub() игнорируют регистр при выполнении операций с регулярными выражениями. ПРИМЕЧАНИЕ: Индексация массивов не затрагивается. Однако функции asort() и asorti() затрагиваются.<br>
Таким образом, если IGNORECASE не равно нулю, /aB/ соответствует всем строкам "ab", "aB", "Ab" и "AB". Как и все переменные AWK, начальное значение IGNORECASE равно нулю, так что все операции с регулярными выражениями и строками обычно чувствительны к регистру.

#### `LINT`
Обеспечивает динамический контроль параметра --lint изнутри программы AWK. Когда true, gawk печатает предупреждения lint. Когда false, он не печатает. Когда присваивается строковое значение "fatal", предупреждения lint становятся фатальными ошибками, точно так же, как --lint=fatal. Любое другое истинное значение просто печатает предупреждения.

#### `NF`
Количество полей в текущей входной записи.

#### `NR`
Общее количество входных записей, увиденных до сих пор.

#### `OFMT`
Формат вывода для чисел, по умолчанию "%.6g".

#### `OFS`
Разделитель выходных полей, по умолчанию пробел.

#### `ORS`
Разделитель выходных записей, по умолчанию символ новой строки.

#### `PREC`
Рабочая точность чисел с произвольной точностью, по умолчанию 53.

#### `PROCINFO`
Элементы этого массива предоставляют доступ к информации о выполняемой программе AWK. На некоторых системах могут быть элементы в массиве "group1" до "groupn" для некоторого n, который является количеством дополнительных групп, к которым принадлежит процесс. Используйте оператор in, чтобы проверить наличие этих элементов. Следующие элементы гарантированно доступны:

##### `PROCINFO`["argv"]     Аргументы командной строки, полученные gawk на уровне языка C. Индексы начинаются с нуля.

##### `PROCINFO`["egid"]     Значение системного вызова getegid(2).

##### `PROCINFO`["errno"]    Значение errno(3), когда ERRNO установлено в соответствующее сообщение об ошибке.

##### `PROCINFO`["euid"]     Значение системного вызова geteuid(2).

##### `PROCINFO`["gid"]      Значение системного вызова getgid(2).

##### `PROCINFO`["identifiers"] Подмассив, индексируемый именами всех идентификаторов, используемых в тексте программы AWK. 
Значения указывают, что gawk знает об идентификаторах после завершения разбора программы; они не обновляются во время выполнения программы. Для каждого идентификатора значение элемента - одно из следующих:
- `"array"`     Идентификатор является массивом.
- `"builtin"`   Идентификатор является встроенной функцией.
- `"extension"` Идентификатор является функцией расширения, загруженной через @load или -l.
- `"scalar"`    Идентификатор является скалярным.
- `"untyped"`   Идентификатор не имеет типа ( может использоваться как скаляр или массив, gawk пока не знает ).
- `"user"`      Идентификатор является пользовательской функцией.

##### `PROCINFO`["pgrpid"]    Идентификатор группы процессов текущего процесса.

##### `PROCINFO`["pid"]       Идентификатор текущего процесса.

##### `PROCINFO`["ppid"]      Идентификатор родительского процесса текущего процесса.

##### `PROCINFO`["strftime"]  Строка формата времени по умолчанию для strftime().

##### `PROCINFO`["uid"]       Значение системного вызова getuid(2).

##### Значения следующих элементов присутствуют, если доступна загрузка динамических расширений:

###### `PROCINFO`["api_major"]  Основная версия API расширения.

###### `PROCINFO`["api_minor"]  Второстепенная версия API расширения.

##### Следующие элементы доступны, если поддержка MPFR скомпилирована в gawk:

###### `PROCINFO`["gmp_version"]  Версия библиотеки GNU MP, используемой для поддержки чисел с произвольной точностью в gawk.

###### `PROCINFO`["mpfr_version"]  Версия библиотеки GNU MPFR, используемой для поддержки чисел с произвольной точностью в gawk.

###### `PROCINFO`["prec_max"]  Максимальная поддерживаемая точность библиотекой GNU MPFR для чисел с произвольной точностью.

###### `PROCINFO`["prec_min"]  Минимальная допустимая точность библиотекой GNU MPFR для чисел с произвольной точностью.

##### Следующие элементы могут быть установлены программой для изменения поведения gawk:

###### `PROCINFO`["NONFATAL"]  Если это существует, то ошибки ввода-вывода для всех перенаправлений становятся нефатальными.

###### `PROCINFO`["ame", "NONFATAL"]  Делает ошибки ввода-вывода для имени нефатальными.

###### `PROCINFO`["command", "pty"]  Использует псевдотерминал для двусторонней связи с командой вместо настройки двух однонаправленных труб.

###### `PROCINFO`["input", "READ_TIMEOUT"] Таймаут в миллисекундах для чтения данных из ввода
где input - это строка перенаправления или имя файла. Значение ноль или меньше нуля означает отсутствие таймаута.

###### `PROCINFO`["input", "RETRY"] 
Если возникает ошибка ввода-вывода, которую можно повторить, при чтении данных из ввода, и этот элемент массива существует, то getline возвращает -2 вместо -1, и дальнейшие вызовы getline могут быть попытаны. Ошибка ввода-вывода, которую можно повторить, - это та, где значение errno(3) равно EAGAIN, EWOULDBLOCK, EINTR или ETIMEDOUT. Это может быть полезно в сочетании с PROCINFO["input", "READ_TIMEOUT"] или ситуациями, когда файловый дескриптор настроен на неблокирующее поведение.

###### `PROCINFO`["sorted_in"] 
Если этот элемент существует в PROCINFO, то его значение контролирует порядок, в котором элементы массива обходятся в циклах for.<br>
Поддерживаемые значения: `"@ind_str_asc"`, `"@ind_num_asc"`, `"@val_type_asc"`, `"@val_str_asc"`, `"@val_num_asc"`, `"@ind_str_desc"`, `"@ind_num_desc"`, `"@val_type_desc"`, `"@val_str_desc"`, `"@val_num_desc"` и `"@unsorted"`.
Значение также может быть именем ( в виде строки ) любой функции сравнения, определённой следующим образом:<br>
```awk
функция cmp_func(i1, v1, i2, v2) { 

}
```
где `i1` и `i2` - индексы, а `v1` и `v2` - соответствующие значения двух сравниваемых элементов.

#### `ROUNDMODE`  Режим округления, используемый для арифметики произвольной точности для чисел
Режим округления, используемый для арифметики произвольной точности для чисел, по умолчанию "N" ( IEEE-754 roundTiesToEven режим ). Принятые значения: "N" или "n" для roundTiesToEven, "U" или "u" для roundTowardPositive, "D" или "d" для roundTowardNegative, "Z" или "z" для roundTowardZero, и если ваша версия библиотеки GNU MPFR поддерживает это, "A" или "a" для округления от нуля.

#### `RS`  Разделитель записей ввода, по умолчанию символ новой строки.

#### `RT`  Завершитель записи. Gawk устанавливает RT в текст ввода, который соответствует символу или регулярному выражению, указанному RS.

#### `RSTART`  Индекс первого символа, совпавшего с match(); 0, если совпадения нет. ( Это подразумевает, что индексы символов начинаются с единицы. )

#### `RLENGTH`  Длина строки, совпавшей с match(); -1, если совпадения нет.

#### `SUBSEP`  Символ, используемый для разделения нескольких индексов в элементах массива, по умолчанию "\034".

#### `SYMTAB`  Массив, индексы которого являются именами всех текущих глобальных переменных и массивов в программе.
Массив может использоваться для косвенного доступа для чтения или записи значения переменной:
```awk
foo = 5
SYMTAB["foo"] = 4
print foo    # печатает 4
```
Функция typeof() может использоваться для проверки, является ли элемент в SYMTAB массивом. Вы не можете использовать оператор delete с массивом SYMTAB.

#### `TEXTDOMAIN`  Текстовый домен программы AWK; используется для поиска локализованных переводов строк программы.

### Массивы
Массивы индексируются выражением между квадратными скобками ( [ и ] ). Если выражение является списком выражений ( expr, expr ... ), то индекс массива является строкой, состоящей из конкатенации ( строкового ) значения каждого выражения, разделённых значением переменной SUBSEP. Эта возможность используется для моделирования многомерных массивов. Например:
```awk
i = "A"; j = "B"; k = "C"
x[i, j, k] = "hello, world\n"
```
присваивает строку "hello, world\n" элементу массива x, индексируемому строкой "A\034B\034C". Все массивы в AWK являются ассоциативными, т.е. индексируются строковыми значениями.
Специальный оператор in может использоваться для проверки, имеет ли массив индекс, состоящий из определённого значения:
```awk
if ( val in array )
print array[val]
```
Если массив имеет несколько индексов, используйте ( i, j ) in array.

Элемент может быть удалён из массива с помощью оператора delete. Оператор delete также может использоваться для удаления всего содержимого массива, просто указав имя массива без индекса.<br>
gawk поддерживает истинные многомерные массивы. Он не требует, чтобы такие массивы были "прямоугольными", как в C или C++. Например:
```awk
a[1] = 5
a[2][1] = 6
a[2][2] = 7
```
**ПРИМЕЧАНИЕ**:<br>
Вам может потребоваться сообщить gawk, что элемент массива на самом деле является подмассивом, чтобы использовать его там, где gawk ожидает массив ( например, во втором аргументе для split() ). Вы можете сделать это, создав элемент в подмассиве, а затем удалив его с помощью оператора delete.

### Типизация переменных и преобразование
Переменные и поля могут быть ( числа с плавающей запятой ) числами, или строками, или тем и другим. Они также могут быть регулярными выражениями. Как значение переменной интерпретируется, зависит от его контекста. Если используется в числовом выражении, оно будет рассматриваться как число; если используется как строка, оно будет рассматриваться как строка.<br>
Чтобы заставить переменную рассматриваться как число, добавьте к ней ноль; чтобы заставить её рассматриваться как строку, конкатенируйте её с пустой строкой.

Неинициализированные переменные имеют числовое значение ноль и строковое значение "" ( пустая строка ).

Когда строка должна быть преобразована в число, преобразование выполняется с использованием strtod(3). Число преобразуется в строку с использованием значения CONVFMT в качестве строки формата для sprintf(3), с числовым значением переменной в качестве аргумента. Однако, хотя все числа в AWK являются числами с плавающей запятой, целые значения всегда преобразуются как целые. Таким образом, учитывая
```awk
CONVFMT = "%2.2f"
a = 12
b = a ""
```
переменная b имеет строковое значение "12", а не "12.00".

**ПРИМЕЧАНИЕ**:<br>
При работе в режиме POSIX ( например, с параметром --posix ) будьте осторожны, что настройки локали могут повлиять на то, как обрабатываются десятичные числа: десятичный разделитель чисел, которые вы передаёте gawk, должен соответствовать тому, что ваша локаль ожидает, будь то запятая ( , ) или точка ( . ).

Gawk выполняет сравнения следующим образом: Если две переменные числовые, они сравниваются численно. Если одно значение числовое, а другое имеет строковое значение, которое является "числовой строкой", то сравнения также выполняются численно. В противном случае числовое значение преобразуется в строку, и выполняется строковое сравнение. Две строки сравниваются, конечно, как строки.

**Обратите внимание**:<br>
Обратите внимание, что строковые константы, такие как "57", не являются числовыми строками, они являются строковыми константами. Идея "числовой строки" применяется только к полям, вводу getline, FILENAME, элементам ARGV, элементам ENVIRON и элементам массива, созданного с помощью split() или patsplit(), которые являются числовыми строками. Основная идея заключается в том, что ввод пользователя, и только ввод пользователя, который выглядит числовым, должен рассматриваться таким образом.

### Восьмеричные и шестнадцатеричные константы
Вы можете использовать константы в восьмеричной и шестнадцатеричной системах в исходном коде вашей программы AWK. Например, восьмеричное значение 011 равно десятичному 9, а шестнадцатеричное значение 0x11 равно десятичному 17.

### Строковые константы
Строковые константы в AWK - это последовательности символов, заключённые в двойные кавычки ( например, "значение" ). Внутри строк распознаются определённые escape-последовательности, как в C. Это:
- `\\`   Литерал обратной косой черты.
- `\a`   Символ "оповещения"; обычно это символ ASCII BEL.
- `\b`   Возврат каретки.
- `\f`   Перенос страницы.
- `\n`   Символ новой строки.
- `\r`   Возврат каретки.
- `\t`   Горизонтальная табуляция.
- `\v`   Вертикальная табуляция.
- `\xhex цифры` Символ, представленный строкой шестнадцатеричных цифр, следующих за `\x`. До двух следующих шестнадцатеричных цифр считаются частью *escape-последовательности*. Например, `"\x1B"` - это символ ASCII `ESC` ( *escape* ).
- `\ddd` Символ, представленный последовательностью из 1, 2 или 3 цифр восьмеричной системы. Например, `"\033"` - это символ ASCII ESC ( *escape* ).
- `\c`   Литерал символа `c`.

В режиме совместимости символы, представленные восьмеричными и шестнадцатеричными *escape-последовательностями*, обрабатываются буквально, когда используются в константах регулярных выражений. Таким образом, `/a\52b/` эквивалентно `/a\*b/`.

### Константы регулярных выражений
Константа регулярного выражения - это последовательность символов, заключённая между косыми чертами ( например, `/значение/` ). Регулярные выражения описаны более подробно ниже; см. [Регулярные выражения](#регулярные-выражения).

Описанные ранее *escape-последовательности* также могут использоваться внутри констант регулярных выражений ( например, `/[ \t\f\n\r\v]/` соответствует пробельным символам ).

Gawk предоставляет строго типизированные константы регулярных выражений. Они записываются с ведущим символом `@` ( например, `@/значение/` ). Такие константы могут быть присвоены скалярам ( переменным, элементам массива ) и переданы в пользовательские функции. Переменные, которые были так присвоены, имеют тип регулярного выражения.

## ШАБЛОНЫ И ДЕЙСТВИЯ
AWK - это язык, ориентированный на строки. Шаблон идёт первым, а затем действие. Операторы действий заключены в `{` и `}`. Либо шаблон может отсутствовать, либо действие может отсутствовать, но, конечно, не оба. Если шаблон отсутствует, действие выполняется для каждой записи ввода. Отсутствующее действие эквивалентно
```awk
{ print }
```
что печатает всю запись.

Комментарии начинаются с символа `#` и продолжаются до конца строки. Пустые строки могут использоваться для разделения операторов. Обычно оператор заканчивается символом новой строки, однако это не так для строк, заканчивающихся запятой, `{`, `?`, `:`, `&&` или `||`. Строки, заканчивающиеся `do` или `else`, также автоматически продолжают свои операторы на следующей строке. В других случаях строку можно продолжить, закончив её символом `"\"`, в этом случае символ новой строки игнорируется.

Несколько операторов могут быть помещены в одну строку, разделяя их символом `;`. Это относится как к операторам внутри части действия пары шаблон-действие ( обычный случай ), так и к операторам шаблонов-действий сами по себе.

### Шаблоны
Шаблоны AWK могут быть одним из следующих:
- `BEGIN`
- `END`
- `BEGINFILE`
- `ENDFILE`
- `/регулярное выражение/`
- `реляционное выражение`
- `шаблон` `&&` `шаблон`
- `шаблон` `||` `шаблон`
- `шаблон` `?` `шаблон` `:` `шаблон`
- `( шаблон )`
- `! шаблон`
- `шаблон1, шаблон2`

`BEGIN` и `END` - это два специальных типа шаблонов, которые не проверяются на входные данные. Операторы действий всех шаблонов `BEGIN` объединяются так, как если бы все операторы были написаны в одном правиле `BEGIN`. Они выполняются до того, как будут прочитаны любые входные данные. Аналогично, все правила `END` объединяются и выполняются, когда все входные данные исчерпаны ( или когда выполняется оператор exit ). Шаблоны `BEGIN` и `END` не могут комбинироваться с другими шаблонами в выражениях шаблонов. Шаблоны `BEGIN` и `END` не могут иметь отсутствующие части действия.

Шаблоны `BEGINFILE` и `ENDFILE` - это дополнительные специальные шаблоны, тела которых выполняются перед чтением первой записи каждого входного файла командной строки и после чтения последней записи каждого файла. Внутри правила `BEGINFILE` значение `ERRNO` является пустой строкой, если файл был успешно открыт. В противном случае возникает проблема с файлом, и код должен использовать `nextfile`, чтобы пропустить его. Если этого не сделать, gawk выдаёт свою обычную фатальную ошибку для файлов, которые не могут быть открыты.

Для шаблонов `/регулярное выражение/` связанный оператор выполняется для каждой записи ввода, которая соответствует регулярному выражению. Регулярные выражения такие же, как в egrep(1), и кратко изложены ниже.

`Реляционное выражение` может использовать любой из операторов, определённых ниже в разделе действий. Эти операторы обычно проверяют, соответствуют ли определённые поля определённым регулярным выражениям.

Операторы `&&`, `||` и `!` являются логическими `И`, `ИЛИ` и `НЕ` соответственно, как в C. Они выполняют короткое замыкание, также как в C, и используются для объединения более примитивных выражений шаблонов. Как и в большинстве языков, скобки могут использоваться для изменения порядка выполнения.

Форма выражения `шаблон1, шаблон2` называется диапазонным шаблоном. Он соответствует всем записям ввода, начиная с записи, которая соответствует `шаблон1`, и продолжается до записи, которая соответствует `шаблон2`, включая её. Он не комбинируется с другими видами выражений шаблонов.

### Регулярные выражения
*Регулярные выражения* являются расширенными, продвинутыми, как в egrep. Они состоят из символов, как показано ниже:
|   |     |
|---|-----|
| **`c`** | Соответствует не-мета-символу c. |
| **`\c`** | Соответствует литералу символа c. |
| **`.`** | Соответствует любому символу, включая новую строку. |
| **`^`** | Соответствует началу строки. |
| **`$`** | Соответствует концу строки. |
| **`[abc...]`** | Список символов: соответствует любому из символов abc.... Вы можете включить диапазон символов, разделив их дефисом. |
| **`[^abc...]`** | Отрицательный список символов: соответствует любому символу, кроме abc.... |
| **`r1\|r2`** | Альтернация: соответствует либо r1, либо r2. |
| **`r1r2`** | Конкатенация: соответствует r1, а затем r2. |
| **`r+`** | Соответствует одному или более r. |
| **`r*`** | Соответствует нулю или более r. |
| **`r?`** | Соответствует нулю или одному r. |
| **`( r )`** | Группировка: соответствует r. |
| **`r{n}`** |  |
| **`r{n,}`** |  |
| **`r{n,m}`** | Одно или два числа внутри фигурных скобок обозначают интервал. Если в фигурных скобках одно число, предшествующее регулярному выражению r повторяется n раз. Если в фигурных скобках два числа, разделённых запятой, r повторяется от n до m раз. Если одно число, за которым следует запятая, то r повторяется как минимум n раз. |
| **`\y`** | Соответствует пустой строке в начале или в конце слова. |
| **`\B`** | Соответствует пустой строке внутри слова. |
| **`\<`** | Соответствует пустой строке в начале слова. |
| **`\>`** | Соответствует пустой строке в конце слова. |
| **`\s`** | Соответствует любому пробельному символу. |
| **`\S`** | Соответствует любому непробельному символу. |
| **`\w`** | Соответствует любому символу, составляющему слово ( буква, цифра или подчёркивание ). |
| **`\W`** | Соответствует любому символу, который не является составляющим слово. |
| **`\`** | Соответствует пустой строке в начале буфера ( строки ). |
| **`\'`** | Соответствует пустой строке в конце буфера. |

#### Escape-последовательности (Escape Sequences)
*Escape-последовательности* - это последовательности символов, которые действительны в строковых константах ( см. [Строковые константы](#строковые-константы) ), также действительны в регулярных выражениях.

#### Классы символов (Character Classes)
*Класс символов* - это функция, введённая в стандарт POSIX. Класс символов - это специальная нотация для описания списков символов, которые имеют определённый атрибут, но фактические символы могут варьироваться от страны к стране и/или от набора символов к набору символов. Например, понятие алфавитного символа отличается в США и во Франции.

*Класс символов* действителен только в регулярном выражении внутри квадратных скобок списка символов. Классы символов состоят из `[:`, ключевого слова, обозначающего класс, и `:]`. Классы символов, определённые стандартом POSIX:

|   |     |
|---|-----|
| `[:alnum:]`  | Алфавитно-цифровые символы. |
| `[:alpha:]`  | Алфавитные символы. |
| `[:blank:]`  | Пробельные или табуляционные символы. |
| `[:cntrl:]`  | Управляющие символы. |
| `[:digit:]`  | Числовые символы. |
| `[:graph:]`  | Символы, которые являются как печатными, так и видимыми. ( Пробел печатный, но не видимый, в то время как "a" является и тем, и другим. ) |
| `[:lower:]`  | Символы алфавита в нижнем регистре. |
| `[:print:]`  | Печатные символы ( символы, которые не являются управляющими символами ). |
| `[:punct:]`  | Символы пунктуации ( символы, которые не являются буквами, цифрами, управляющими символами или пробельными символами ). |
| `[:space:]`  | Пробельные символы ( такие как пробел, табуляция и перенос страницы, чтобы назвать несколько ). |
| `[:upper:]`  | Символы алфавита в верхнем регистре. |
| `[:xdigit:]`  | Символы, которые являются шестнадцатеричными цифрами. |

Например, до стандарта POSIX, чтобы соответствовать алфавитно-цифровым символам, вам нужно было бы написать `/[A-Za-z0-9]/`. Если ваш набор символов имел другие алфавитные символы, это не соответствовало бы им, и если ваш набор символов сортировался иначе, чем ASCII, это могло бы даже не соответствовать ASCII алфавитно-цифровым символам. С классами символов POSIX вы можете написать `/[:alnum:]/`, и это соответствует алфавитным и числовым символам в вашем наборе символов, независимо от того, какой он.

Две дополнительные специальные последовательности могут появляться в списках символов. Они применяются к не-ASCII наборам символов, которые могут иметь отдельные символы ( называемые элементами сортировки ), которые представлены более чем одним символом, а также нескольким символам, которые эквивалентны для сортировки. ( Например, во французском языке обычная `"e"` и `"e"` с акцентом являются эквивалентными. )

#### Символ сортировки (Collating Symbols)
*Символ сортировки* - это многосимвольный элемент сортировки, заключённый в `[.` и `.]`. Например, если `ch` - это элемент сортировки, то `[[.ch.]]` - это регулярное выражение, которое соответствует этому элементу сортировки, в то время как `[ch]` - это регулярное выражение, которое соответствует либо `c`, либо `h`.

#### Класс эквивалентности (Equivalence Classes)
*Класс эквивалентности* - это специфичное для локали имя для списка символов, которые эквивалентны. Имя заключено в `[=` и `=]`. Например, имя `e` может использоваться для представления всех `"e"`, `"´"` и `"``". В этом случае `[[=e=]]` - это регулярное выражение, которое соответствует любому из `e`, `´` или `"``".

Эти функции очень ценны в неанглоязычных локалях. Библиотечные функции, которые gawk использует для сопоставления регулярных выражений, в настоящее время распознают только классы символов POSIX; они не распознают символы сортировки или классы эквивалентности.

Операторы `\y`, `\B`, `\<`, `\>`, `\s`, `\S`, `\w`, `\W`, `\`, и `\'` являются специфичными для gawk; они являются расширениями, основанными на возможностях в библиотеках GNU регулярных выражений.

Различные параметры командной строки контролируют, как gawk интерпретирует символы в регулярных выражениях.

|   |   |
|---|---|
| *без параметров* | В случае по умолчанию gawk предоставляет все возможности POSIX регулярных выражений и операторы GNU регулярных выражений, описанные выше. |
| `--posix` | Поддерживаются только POSIX регулярные выражения, операторы GNU не являются специальными. ( Например, \w соответствует литералу w ). |
| `--traditional` | Сопоставляются традиционные регулярные выражения UNIX awk. Операторы GNU не являются специальными, и интервальные выражения недоступны. Символы, описанные восьмеричными и шестнадцатеричными escape-последовательностями, обрабатываются буквально, даже если они представляют собой метасимволы регулярных выражений. |
| `--re-interval` | Разрешает интервальные выражения в регулярных выражениях, даже если `--traditional` был предоставлен. |

### Действия (Actions)
Операторы действий заключены в фигурные скобки, `{` и `}`. Операторы действий состоят из обычных операторов присвоения, условных и циклических операторов, найденных в большинстве языков. Операторы, управляющие операторами ввода/вывода, и операторы, доступные в AWK, основаны на тех, что в C.

### Операторы (Operators)
Операторы в AWK, в порядке убывания приоритета, следующие:
|   |   |
|---|---|
| `( ... )` | Группировка |
| `$` | Ссылка на поле. |
| `++` `--` | Инкремент и декремент, как префиксные, так и постфиксные. |
| `^` | Возведение в степень ( ** также может использоваться, и **= для оператора присвоения ). |
| `+` `-` `!` | Унарный плюс, унарный минус и логическое отрицание. |
| `*` `/` `%` | Умножение, деление и остаток. |
| `+` `-` | Сложение и вычитание. |
| `space` | Конкатенация строк. |
| `&` | Проводной ввод-вывод для getline, print и printf. |
| `<` `>` `<=` `>=` `==` `!=` | Обычные реляционные операторы. |
| `~` `!~` | Сопоставление регулярных выражений, отрицательное сопоставление. ПРИМЕЧАНИЕ: Не используйте постоянное регулярное выражение ( /foo/ ) на левой стороне ~ или !~. Используйте только одно справа. Выражение /foo/ ~ exp имеет то же значение, что и ( ( $0 ~ /foo/ ) ~ exp ). Обычно это не то, что вы хотите. |
| `&&` | Логическое И. |
| `\|\|` | Логическое ИЛИ. |
| `in` | Членство в массиве. |
| `?:` | Условное выражение C. Оно имеет форму **`expr1` `?` `expr2` `:` `expr3`**. Если `expr1` истинно, значение выражения равно `expr2`, в противном случае - `expr3`.<br> **Вычисляется только одно значение:** `expr2` или `expr3`. |
| `=` `+=` `-=` `*=` `/=` `%=` `^=` | Присвоение. Поддерживаются как абсолютное присвоение ( var = value ), так и оператор-присвоение ( другие формы ). |

### Управляющие конструкции (Control Statements)
Управляющие конструкции следующие:

- **`if`** **`(`** условие **`)`** оператор **`[`** **`else`** оператор **`]`**
- **`while`** **`(`** условие **`)`** оператор
- **`do`** оператор **`while`** **`(`** условие **`)`**
- **`for`** **`(`** expr1; expr2; expr3 **`)`** оператор
- **`for`** **`(`** var **`in`** array **`)`** оператор
- **`break`**
- **`continue`**
- **`delete`** array`[`index`]`
- **`delete`** array
- **`exit`** `[` выражение `]`
- **`{`** операторы **`}`**
- **`switch`**

```awk
switch ( выражение ) {
    case значение|regex : оператор
    ...
   [ default: оператор ]  
}
```

### Операторы ввода/вывода (I/O Statements)
Операторы ввода/вывода следующие:

| Оператор | Описание |
|----------|----------|
| `close( файл [, как] )` | Закрывает файл, трубу или сопроцесс. Необязательный как должен использоваться только при закрытии одного конца двухсторонней трубы к сопроцессу. Это должно быть строковым значением, либо "to", либо "from". |
| `getline` | Устанавливает `$0` из следующей записи ввода; устанавливает NF, NR, FNR, RT. |
| `getline < файл` | Устанавливает `$0` из следующей записи файла; устанавливает NF, RT. |
| `getline var` | Устанавливает var из следующей записи ввода; устанавливает NR, FNR, RT. |
| `getline var < файл` | Устанавливает var из следующей записи файла, RT. |
| `команда \| getline [var]` | Выполняет команду, перенаправляя вывод либо в $0, либо в var, как указано выше, и RT. |
| `команда \|& getline [var]` | Выполняет команду как сопроцесс, перенаправляя вывод либо в $0, либо в var, как указано выше, и RT. Сопроцессы являются расширением gawk. ( команда также может быть сокетом. См. подраздел Специальные имена файлов ниже. ) |
| `next` | Останавливает обработку текущей записи ввода. Следующая запись ввода читается, и обработка начинается заново с первого шаблона в программе AWK. После достижения конца входных данных gawk выполняет любые правила END. |
| `nextfile` | Останавливает обработку текущего входного файла. Следующая запись, которую читают, поступает из следующего входного файла. ИМЯ_ФАЙЛА и ARGIND обновляются, FNR сбрасывается на 1, и обработка начинается заново с первого шаблона в программе AWK. После достижения конца входных данных gawk выполняет любые правила ENDFILE и END. |
| `print` | Печатает текущую запись. Выходная запись завершается значением ORS. |
| `print expr-list` | Печатает выражения. Каждое выражение разделяется значением OFS. Выходная запись завершается значением ORS. |
| `print expr-list > файл` | Печатает выражения в файл. Каждое выражение разделяется значением OFS. Выходная запись завершается значением ORS. |
| `printf fmt, expr-list` | Форматирует и печатает. См. Оператор printf ниже. |
| <span style='white-space: nowrap;'>`printf fmt, expr-list > файл`</span> | Форматирует и печатает в файл. |
| `system( cmd-line )` | Выполняет команду cmd-line и возвращает код завершения. ( Это может быть недоступно на не-POSIX системах. ) См. GAWK: Эффективное программирование на AWK для получения полных деталей о коде завершения. |
| `fflush( [файл] )` | Очищает любые буферы, связанные с открытым выходным файлом или файлом трубы. Если файл отсутствует или является пустой строкой, то очищаются все открытые выходные файлы и трубы. |

Дополнительные перенаправления вывода разрешены для print и printf.

```awk
print ... >> файл
```
Добавляет вывод в файл.
```awk
print ... | команда
```
Записывает в трубу.

```awk
print ... |& команда
```
Отправляет данные в сопроцесс или сокет. ( См. также подраздел Специальные имена файлов ниже. )

Команда `getline` возвращает `1` при успешном выполнении, `0` — при достижении конца файла и `-1` — в случае ошибки. Если значение `errno(3)` указывает, что операцию ввода-вывода можно повторить, и установлен элемент массива `PROCINFO["input", "RETRY"]`, то возвращается `-2` вместо `-1`, и можно попытаться вызвать `getline` снова. В случае ошибки переменная `ERRNO` устанавливается в строку с описанием проблемы.

**ПРИМЕЧАНИЕ:** Ошибка при открытии двухстороннего сокета приводит к тому, что возвращается нефатальная ошибка в вызывающую функцию. Если вы используете трубу, сопроцесс или сокет для getline, или из print или printf в цикле, вы должны использовать close(), чтобы создать новые экземпляры команды или сокета. AWK не закрывает автоматически трубы, сокеты или сопроцессы, когда они возвращают EOF.

### Оператор printf
AWK версии оператора `printf` и функции `sprintf()` (см. ниже) принимают следующие форматы спецификации преобразования:

| Спецификатор | Описание |
|--------------|----------|
| `%c`           |     Один символ. Если аргумент, используемый для %c, является числовым, он обрабатывается как символ и печатается. В противном случае аргумент предполагается как строка, и печатается только первый символ этой строки. |
| `%d, %i`       |     Десятичное число (целая часть). |
| `%e, %E`       |     Число с плавающей запятой в форме [-]d.dddddde[+-]dd. Формат `%E` использует `E` вместо `e`. |
| `%f, %F`       |     Число с плавающей запятой в форме [-]ddd.dddddd. Если системная библиотека поддерживает это, `%F` также доступен. Это похоже на `%f`, но использует заглавные буквы для специальных значений "не число" и "бесконечность". Если `%F` недоступен, gawk использует `%f`. |
| `%g, %G`       |     Используйте `%e` или `%f` преобразование, в зависимости от того, что короче, с подавлением незначащих нулей. Формат `%G` использует `%E` вместо `%e`. |
| `%o`             |     Беззнаковое восьмеричное число (также целое). |
| `%u`             |     Беззнаковое десятичное число (снова целое). |
| `%s`           |     Строка символов. |
| `%x, %X`       |     Беззнаковое шестнадцатеричное число (целое). Формат %X использует ABCDEF вместо abcdef. |
| `%%`           |     Один символ %; никакой аргумент не преобразуется. |


Необязательные дополнительные параметры могут находиться между % и управляющей буквой:
| Параметр     | Описание |
|--------------|----------|
| `count$` | Используйте count-й аргумент в этой точке в формате. Это называется позиционным спецификатором и предназначено в первую очередь для использования в переводимых версиях строк формата, а не в оригинальном тексте программы AWK. Это расширение gawk. |
| `-` | Выражение должно быть выровнено по левому краю в своём поле. |
| `space` | Для числовых преобразований, префикс положительных значений пробелом, а отрицательных значений знаком минус. |
| `+` | Знак плюс, используемый перед модификатором ширины (см. ниже), говорит о том, что всегда следует указывать знак для числовых преобразований, даже если данные, которые нужно форматировать, положительны. Знак + отменяет модификатор space. |
| `#` | Используйте "альтернативную форму" для определённых управляющих букв. Для %o укажите ведущий ноль. Для %x и %X укажите ведущий 0x или 0X для ненулевого результата. Для %e, %E, %f и %F результат всегда содержит десятичную точку. Для %g и %G не удаляются конечные нули из результата. |
| `0` | Ведущий 0 (ноль) действует как флаг, указывающий, что вывод должен быть дополнен нулями вместо пробелов. Это применяется только к числовым форматам вывода. Этот флаг имеет эффект только тогда, когда ширина поля шире, чем значение, которое нужно напечатать. |
| `'` | Один символ апострофа указывает gawk вставить символ разделителя тысяч в десятичных числах и также использовать символ десятичной точки локали с форматами с плавающей запятой. Это требует правильной поддержки локали в библиотеке C и в определении текущей локали. |
| `width` | Поле должно быть дополнено до этой ширины. Поле обычно дополняется пробелами. С флагом 0 оно дополняется нулями. |
| `.prec` | Число, которое указывает точность, которую следует использовать при печати. Для форматов %e, %E, %f и %F это указывает количество цифр, которые вы хотите напечатать справа от десятичной точки. Для форматов %g и %G это указывает максимальное количество значащих цифр. Для форматов %d, %i, %o, %u, %x и %X это указывает минимальное количество цифр для печати. Для %s это указывает максимальное количество символов из строки, которые должны быть напечатаны. |

Поддерживаются динамические возможности ширины и точности стандартных процедур `printf()` ISO C. Звёздочка вместо спецификаций ширины или точности вызывает получение их значений из списка аргументов для `printf` или `sprintf()`. Чтобы использовать позиционный спецификатор с динамической шириной или точностью, укажите `count$` после `*` в строке формата. Например, `"%3$*2$.*1$s"`.

### Специальные имена файлов
При перенаправлении ввода-вывода из print или printf в файл или через getline из файла gawk распознаёт определённые специальные имена файлов. Эти имена файлов позволяют получить доступ к открытым файловым дескрипторам, унаследованным от родительского процесса gawk (обычно оболочки). Эти имена файлов также могут использоваться в командной строке для указания файлов данных. Эти имена файлов особенно полезны для сообщений об ошибках. Например:
```awk
print "Вы ошиблись!" > "/dev/stderr"
```
в то время как вам в противном случае пришлось бы использовать
```awk
print "Вы ошиблись!" | "cat 1>&2"
```

Следующие специальные имена файлов могут использоваться с оператором `|&` сопроцесса для создания TCP/IP сетевых соединений:

- Файлы для TCP/IP соединения на локальном порту lport к удалённому хосту rhost на удалённом порту rport. Используйте порт 0, чтобы позволить системе выбрать порт. Используйте /inet4, чтобы принудительно установить соединение IPv4, и /inet6, чтобы принудительно установить соединение IPv6. Обычное /inet использует системный стандарт (скорее всего, IPv4):
  - **`/inet/tcp/lport/rhost/rport`**
  - **`/inet4/tcp/lport/rhost/rport`**
  - **`/inet6/tcp/lport/rhost/rport`**
- Аналогично, но использует UDP/IP вместо TCP/IP:
  - **`/inet/udp/lport/rhost/rport`**
  - **`/inet4/udp/lport/rhost/rport`**
  - **`/inet6/udp/lport/rhost/rport`**

### Числовые функции
AWK имеет следующие встроенные арифметические функции:
| Функция | Описание |
|---------|----------|
| `atan2(y, x)` | Возвращает арктангенс y/x в радианах. |
| `cos(expr)` | Возвращает косинус expr, который находится в радианах. |
| `exp(expr)` | Экспоненциальная функция. |
| `int(expr)` | Округляет до целого. |
| `log(expr)` | Натуральный логарифм. |
| `rand()` | Возвращает случайное число N, между нулём и единицей, так что 0 ≤ N < 1. |
| `sin(expr)` | Возвращает синус expr, который находится в радианах. |
| `sqrt(expr)` | Возвращает квадратный корень из expr. |
| `srand([expr])` | Использует expr в качестве нового семени для генератора случайных чисел. Если expr не предоставлено, используется текущее время. Возвращает предыдущее семя для генератора случайных чисел. |

### Строковые функции
Gawk имеет следующие встроенные строковые функции:

| Функция | Описание |
|---------|----------|
| `asort(s [, d [, how] ])` | Возвращает количество элементов в исходном массиве `s`. Сортирует содержимое `s`, используя обычные правила gawk для сравнения значений, и заменяет индексы отсортированных значений `s` последовательными целыми числами, начиная с 1. Если указанный массив назначения `d`, сначала дублирует `s` в `d`, а затем сортирует `d`, оставляя индексы исходного массива `s` неизменными. Необязательная строка `how` контролирует направление и режим сравнения. Допустимые значения для `how` - это любые строки, действительные для `PROCINFO["sorted_in"]`. Это также может быть имя пользовательской функции сравнения, как описано в `PROCINFO["sorted_in"]`. |
| `asorti(s [, d [, how] ])` | Возвращает количество элементов в исходном массиве `s`. Поведение такое же, как у `asort()`, за исключением того, что индексы массива используются для сортировки, а не значения массива. Когда завершено, массив индексируется численно, а значения - это оригинальные индексы. Оригинальные значения теряются; поэтому предоставьте второй массив, если вы хотите сохранить оригинальное. |
| `gensub(r, s, h [, t])` | Ищет целевую строку `t` на совпадения регулярного выражения `r`. Если `h` - это строка, начинающаяся с `g` или `G`, то заменяет все совпадения `r` на `s`. В противном случае `h` - это число, указывающее, какое совпадение `r` заменить. Если `t` не указано, используется `$0` вместо этого. Внутри текста замены `s` последовательность `\n`, где `n` - это цифра от `1` до `9`, может использоваться для указания только текста, который совпал с `n`-ым родительским выражением. Последовательность `\0` представляет собой весь совпавший текст, как и символ `&`. В отличие от `sub()` и `gsub()`, изменённая строка возвращается в качестве результата функции, а оригинальная целевая строка не изменяется. |
| `gsub(r, s [, t])` | Для каждой подстроки, соответствующей регулярному выражению r в строке t, заменяет строку s и возвращает количество замен. Если t не указано, используется $0. Символ & в тексте замены заменяется текстом, который фактически совпал. Используйте \&, чтобы получить литерал &. (Это должно быть напечатано как "\\&"; см. GAWK: Эффективное программирование на AWK для более полного обсуждения правил для амперсандов и обратных косых черт в тексте замены sub(), gsub() и gensub().) |
| `index(s, t)` | Возвращает индекс строки t в строке s, или ноль, если t отсутствует. (Это подразумевает, что индексы символов начинаются с единицы. ) Для t использовать регулярное выражение является фатальной ошибкой. |
| `length([s])` | Возвращает длину строки `s`, или длину `$0`, если `s` не указано. Как нестандартное расширение, с аргументом массива `length()` возвращает количество элементов в массиве. |
| `match(s, r [, a])` | Возвращает позицию в `s`, где регулярное выражение `r` встречается, или ноль, если `r` отсутствует, и устанавливает значения `RSTART` и `RLENGTH`. Обратите внимание, что порядок аргументов такой же, как для оператора `~`: `str ~ re`.<br>Если массив `a` предоставлен, `a` очищается, а затем элементы `1` до `n` заполняются частями `s`, которые соответствуют соответствующему родительскому выражению в `r`. Нулевой элемент `a` содержит часть `s`, совпавшую с полным регулярным выражением `r`. Индексы `a[n, "start"]` и `a[n, "length"]` предоставляют начальный индекс в строке и длину соответственно для каждой совпадающей подстроки. |
| <span style='white-space: nowrap;'>`patsplit(s, a [, r [, seps] ])`</span> | Разбивает строку s на массив a и массив разделителей seps по регулярному выражению r и возвращает количество полей. Элементы a содержат части s, которые совпадают с r. Значение seps[i] - это, возможно, пустой разделитель, который появился после a[i]. Значение seps[0] - это, возможно, пустой ведущий разделитель. Если r не указан, используется FPAT. Массивы a и seps очищаются сначала. Разбиение ведёт себя идентично разделению полей с FPAT, описанному выше. |
| `split(s, a [, r [, seps] ])` | Разбивает строку s на массив a и массив разделителей seps по регулярному выражению r и возвращает количество полей. Если r не указан, используется FS вместо этого. Массивы a и seps очищаются сначала. seps[i] - это разделитель поля, совпавший с r между a[i] и a[i+1]. Если r - это один пробел, то ведущие пробелы в s попадают в дополнительный элемент массива seps[0], а конечные пробелы попадают в дополнительный элемент массива seps[n], где n - это возвращаемое значение split(s, a, r, seps). Разбиение ведёт себя идентично разделению полей, описанному выше. |
| `sprintf(fmt, expr-list)` | Печатает expr-list в соответствии с fmt и возвращает результирующую строку. |
| `strtonum(str)` | Изучает str и возвращает его числовое значение. Если str начинается с ведущего 0, обрабатывает его как восьмеричное число. Если str начинается с ведущего 0x или 0X, обрабатывает его как шестнадцатеричное число. В противном случае предполагает, что это десятичное число. |
| `sub(r, s [, t])` | Точно так же, как gsub(), но заменяет только первое совпадение подстроки. Возвращает либо ноль, либо один. |
| `substr(s, i [, n])` | Возвращает подстроку длиной не более n символов из s, начиная с i. Если n не указано, используется остальная часть s. |
| `tolower(str)` | Возвращает копию строки str, в которой все заглавные буквы в str преобразованы в соответствующие строчные буквы. Непечатные символы остаются неизменными. |
| `toupper(str)` | Возвращает копию строки str, в которой все строчные буквы в str преобразованы в соответствующие заглавные буквы. Непечатные символы остаются неизменными. |

Gawk осведомлён о многобайтовых символах. Это означает, что index(), length(), substr() и match() работают с точки зрения символов, а не байтов.

### Функции времени
Поскольку одной из основных целей программ AWK является обработка файлов журналов, содержащих информацию о временных метках, gawk предоставляет следующие функции для получения временных меток и их форматирования.

#### `mktime(datespec [, utc-flag])` 
Превращает `datespec` в временную метку того же формата, что и возвращаемая `systime()`, и возвращает результат. datespec - это строка формата YYYY MM DD HH MM SS[ DST]. Содержимое строки состоит из шести или семи чисел, представляющих соответственно полный год, включая век, месяц от 1 до 12, день месяца от 1 до 31, час дня от 0 до 23, минуту от 0 до 59, секунду от 0 до 60 и необязательный флаг перехода на летнее время. Значения этих чисел не обязательно должны находиться в указанных диапазонах; например, час -1 означает 1 час до полуночи. Предполагается, что используется григорианский календарь с нулевым началом, где год 0 предшествует году 1, а год -1 предшествует году 0. Если utc-flag присутствует и не равен нулю или пустой строке, время предполагается в часовом поясе UTC; в противном случае время предполагается в местном часовом поясе. Если флаг перехода на летнее время положителен, время предполагается в летнем времени; если ноль, время предполагается в стандартном времени; если отрицательный (по умолчанию), mktime() пытается определить, находится ли переход на летнее время в действии для указанного времени. Если datespec не содержит достаточного количества элементов или если полученное время выходит за пределы диапазона, mktime() возвращает -1.

#### `strftime([format [, timestamp[, utc-flag]]])` 
Форматирует timestamp в соответствии со спецификацией в format. Если utc-flag присутствует и не равен нулю или пустой строке, результат будет в UTC, в противном случае результат будет в местном времени. timestamp должен быть того же формата, что и возвращаемое systime(). Если timestamp отсутствует, используется текущее время суток. Если format отсутствует, используется формат по умолчанию, эквивалентный выводу date(1). Формат по умолчанию доступен в PROCINFO["strftime"]. См. спецификацию для функции strftime() в ISO C для гарантированных преобразований формата.

#### `systime()` 
Возвращает текущее время суток в виде количества секунд с начала эпохи (1970-01-01 00:00:00 UTC на POSIX системах).

### Функции манипуляции битами
Gawk предоставляет следующие функции манипуляции битами. Они работают, преобразуя значения с плавающей запятой двойной точности в целые числа uintmax_t, выполняя операцию, а затем преобразуя результат обратно в число с плавающей запятой.

**ПРИМЕЧАНИЕ:** Передача отрицательных операндов в любую из этих функций вызывает фатальную ошибку.

Функции:
| Функция | Описание |
|---------|----------|
| `and(v1, v2 [, ...])` | Возвращает побитовый И значений, предоставленных в списке аргументов. Должно быть как минимум два. |
| `compl(val)` | Возвращает побитовую инверсию val. |
| `lshift(val, count)` | Возвращает значение val, сдвинутое влево на count бит. |
| `or(v1, v2 [, ...])` | Возвращает побитовый ИЛИ значений, предоставленных в списке аргументов. Должно быть как минимум два. |
| `rshift(val, count)` | Возвращает значение val, сдвинутое вправо на count бит. |
| `xor(v1, v2 [, ...])` | Возвращает побитовый исключающий ИЛИ значений, предоставленных в списке аргументов. Должно быть как минимум два. |

### Функции типов
| Функция | Описание |
|---------|----------|
| `isarray(x)` | Возвращает `true`, если `x` является массивом, `false` в противном случае. |
| `typeof(x)` | Возвращает строку, указывающую тип x. Строка будет одной из `"array"`, `"number"`, `"regexp"`, `"string"`, `"strnum"` или `"undefined"`. |

### Функции интернационализации
Следующие функции могут использоваться изнутри вашей программы AWK для перевода строк во время выполнения. Для получения полных деталей см. GAWK: Эффективное программирование на AWK.

**`bindtextdomain(directory [, domain])`**
        Указывает каталог, в котором gawk ищет файлы .gmo, в случае, если их нельзя разместить в "стандартных" местах (например, во время тестирования). Он возвращает каталог, в котором домен "связан".
        Стандартный домен - это значение переменной TEXTDOMAIN. Если каталог - пустая строка (""), то bindtextdomain() возвращает текущее связывание для данного домена.

**`dcgettext(string [, domain [, category]])`**
        Возвращает перевод строки в текстовом домене domain для категории локали category. Стандартное значение для domain - это текущее значение TEXTDOMAIN. Стандартное значение для category - "LC_MESSAGES".
        Если вы предоставите значение для category, оно должно быть строкой, равной одной из известных категорий локали, описанных в GAWK: Эффективное программирование на AWK. Вы также должны предоставить текстовый домен. Используйте TEXTDOMAIN, если хотите использовать текущий домен.

**`dcngettext(string1, string2, number [, domain [, category]])`**
        Возвращает множественную форму, используемую для числа перевода string1 и string2 в текстовом домене domain для категории локали category. Стандартное значение для domain - текущее значение TEXTDOMAIN. Стандартное значение для category - "LC_MESSAGES".
        Если вы предоставите значение для category, оно должно быть строкой, равной одной из известных категорий локали, описанных в GAWK: Эффективное программирование на AWK. Вы также должны предоставить текстовый домен. Используйте TEXTDOMAIN, если хотите использовать текущий домен.

### ПОЛЬЗОВАТЕЛЬСКИЕ ФУНКЦИИ
Функции в AWK определяются следующим образом:
```awk
function имя(список параметров) { 
       операторы 
}
```
Функции выполняются, когда они вызываются из выражений в шаблонах или действиях. Фактические параметры, переданные в вызове функции, используются для инициализации формальных
параметров, объявленных в функции. Массивы передаются по ссылке, другие переменные передаются по значению.

Поскольку функции изначально не были частью языка AWK, возможность использования локальных переменных довольно неудобна: они объявляются как дополнительные параметры в списке параметров.
Принято отделять локальные переменные от реальных параметров дополнительными пробелами в списке параметров. Например:
```awk
function  f(p, q,     a, b)   # a и b - локальные
{
       ...
}

/abc/     { ... ; f(1, 2) ; ... }
```

Левая скобка в вызове функции должна немедленно следовать за именем функции, без промежуточных пробелов. Это избегает синтаксической неоднозначности с оператором конкатенации.
Это ограничение не применяется к встроенным функциям, перечисленным выше.

Функции могут вызывать друг друга и могут быть рекурсивными. Параметры функции, используемые как локальные переменные, инициализируются пустой строкой и числом ноль при вызове функции.

Используйте return expr, чтобы вернуть значение из функции. Возвращаемое значение неопределено, если значение не предоставлено или если функция возвращается, "упав" с конца.

Как расширение gawk, функции могут вызываться косвенно. Для этого присвойте имя функции, которую нужно вызвать, в виде строки переменной. Затем используйте переменную так, как если бы это
было имя функции, с префиксом @, например:
```awk
function myfunc()
{
       print "myfunc вызвана"
       ...
}

{    ...
       the_func = "myfunc"
       @the_func()    # вызов через the_func к myfunc
       ...
}
```
Начиная с версии 4.1.2, это работает с пользовательскими функциями, встроенными функциями и функциями расширения.

Если был предоставлен --lint, gawk предупреждает о вызовах неопределенных функций на этапе разбора, а не во время выполнения. Вызов неопределенной функции во время выполнения является фатальной ошибкой.

Слово func может использоваться вместо function, хотя это устарело.

## ДИНАМИЧЕСКАЯ ЗАГРУЗКА НОВЫХ ФУНКЦИЙ
Вы можете динамически добавлять новые встроенные функции в работающий интерпретатор gawk с помощью оператора @load. Полные детали выходят за рамки этой страницы руководства; смотрите GAWK:
Эффективное программирование на AWK.

## СИГНАЛЫ
Профайлер gawk принимает два сигнала. SIGUSR1 заставляет его сбросить профиль и стек вызовов функций в файл профиля, который либо awkprof.out, либо любой файл, указанный с помощью параметра --profile. Затем он продолжает работу. SIGHUP заставляет gawk сбросить профиль и стек вызовов функций, а затем выйти.

## МЕЖДУНАРОДНАЯ АДАПТАЦИЯ
Строковые константы — это последовательности символов, заключенные в двойные кавычки. В неанглоязычных средах возможно пометить строки в программе AWK как требующие перевода на местный язык. Такие строки помечаются в программе AWK ведущим подчеркиванием (“_”). Например,
```bash
gawk 'BEGIN { print "hello, world" }'
```
всегда выводит hello, world. Но,
```bash
gawk 'BEGIN { print _"hello, world" }'
```
может вывести bonjour, monde во Франции.

Существует несколько шагов, необходимых для создания и запуска локализуемой программы AWK.

1.  Добавьте действие BEGIN, чтобы присвоить значение переменной TEXTDOMAIN, чтобы установить текстовый домен на имя, связанное с вашей программой:
```awk
BEGIN { TEXTDOMAIN = "myprog" }
```
Это позволяет gawk найти файл .gmo, связанный с вашей программой. Без этого шага gawk использует текстовый домен сообщений, который, вероятно, не содержит переводов для вашей программы.

2.  Пометьте все строки, которые должны быть переведены, ведущими подчеркиваниями.

3.  При необходимости используйте функции dcgettext() и/или bindtextdomain() в вашей программе, если это необходимо.

4.  Запустите `gawk --gen-pot -f myprog.awk > myprog.pot`, чтобы сгенерировать файл `.pot` для вашей программы.

5.  Предоставьте соответствующие переводы и создайте и установите соответствующие файлы `.gmo`.

Функции интернационализации описаны в полном объеме в GAWK: Эффективное программирование на AWK.

## СОВМЕСТИМОСТЬ С POSIX
Основная цель gawk — совместимость со стандартом POSIX, а также с последней версией awk Брайана Кернигана. Для этого gawk включает следующие видимые пользователю функции, которые не описаны в книге AWK, но являются частью версии awk Брайана Кернигана и входят в стандарт POSIX.

В книге указано, что присвоение переменных командной строки происходит, когда awk в противном случае открыл бы аргумент как файл, что происходит после выполнения правила BEGIN. Однако в более ранних реализациях, когда такое присвоение появлялось перед любыми именами файлов, присвоение происходило до выполнения правила BEGIN. Приложения стали зависеть от этой “функции”. Когда awk был изменен, чтобы соответствовать своей документации, была добавлена опция -v для присвоения переменных до выполнения программы, чтобы учесть приложения, которые зависели от старого поведения. (Эта функция была согласована как Bell Laboratories, так и разработчиками GNU.)

При обработке аргументов gawk использует специальный параметр “--”, чтобы сигнализировать о конце аргументов. В режиме совместимости он предупреждает о неопределенных параметрах, но в остальном игнорирует их. В нормальном режиме такие аргументы передаются в программу AWK для обработки.

Книга AWK не определяет возвращаемое значение srand(). Стандарт POSIX требует, чтобы он возвращал используемое семя, чтобы отслеживать последовательности случайных чисел. Поэтому srand() в gawk также возвращает текущее семя.

## ИСТОРИЧЕСКИЕ ОСОБЕННОСТИ
Существует одна особенность исторических реализаций AWK, которую поддерживает gawk: возможно вызывать встроенную функцию length() не только без аргумента, но даже без скобок! Таким образом,
```awk
a = length     # Holy Algol 60, Batman!
```
эквивалентно любому из
```awk
a = length()
a = length($0)
```
Использование этой функции является плохой практикой, и gawk выдает предупреждение о ее использовании, если на командной строке указана опция `--lint`.

## РАСШИРЕНИЯ GNU
Gawk имеет слишком много расширений к POSIX awk. Они описаны в этом разделе. Все описанные здесь расширения могут быть отключены, если вызвать gawk с параметрами --traditional или --posix.

Следующие функции gawk недоступны в POSIX awk.

- Поиск пути не выполняется для файлов, указанных с помощью параметра -f. Поэтому переменная окружения AWKPATH не является специальной.
- Нет возможности включения файлов (механизм @include gawk).
- Нет возможности динамически добавлять новые функции, написанные на C (механизм @load gawk).
- Эскейп-последовательность \x.
- Возможность продолжать строки после ? и :.
- Восьмеричные и шестнадцатеричные константы в программах AWK.
- Переменные ARGIND, BINMODE, ERRNO, LINT, PREC, ROUNDMODE, RT и TEXTDOMAIN не являются специальными.
- Переменная IGNORECASE и ее побочные эффекты недоступны.
- Переменная FIELDWIDTHS и разбиение полей фиксированной ширины.
- Переменная FPAT и разбиение полей на основе значений полей.
- Массивы FUNCTAB, SYMTAB и PROCINFO недоступны.
- Использование RS как регулярного выражения.
- Специальные имена файлов, доступные для перенаправления ввода-вывода, не распознаются.
- Оператор |& для создания сопроцессов.
- Специальные шаблоны BEGINFILE и ENDFILE недоступны.
- Возможность выделять отдельные символы, используя пустую строку в качестве значения FS и в качестве третьего аргумента для split().
- Необязательный четвертый аргумент для split(), чтобы получить тексты разделителей.
· Необязательный второй аргумент для функции close().
- Необязательный третий аргумент для функции match().
- Возможность использовать позиционные спецификаторы с printf и sprintf().
- Возможность передавать массив в length().
- Функции and(), asort(), asorti(), bindtextdomain(), compl(), dcgettext(), dcngettext(), gensub(), lshift(), mktime(), or(), patsplit(), rshift(), strftime(), strtonum(), systime() и xor().
- Локализуемые строки.
- Нефатальный ввод-вывод.
- Повторяемый ввод-вывод.

Книга AWK не определяет возвращаемое значение функции close(). Функция close() gawk возвращает значение из fclose(3) или pclose(3) при закрытии выходного файла или канала соответственно. Она возвращает статус выхода процесса при закрытии входного канала. Возвращаемое значение равно -1, если указанный файл, канал или сопроцесс не был открыт с перенаправлением.

Когда gawk вызывается с параметром --traditional, если аргумент fs для параметра -F равен “t”, то FS устанавливается в символ табуляции. Обратите внимание, что ввод gawk -F\t ... просто заставляет оболочку экранировать “t” и не передает “\t” в параметр -F. Поскольку это довольно неприятный специальный случай, он не является поведением по умолчанию. Это поведение также не происходит, если указана опция --posix. Чтобы действительно получить символ табуляции в качестве разделителя полей, лучше использовать одинарные кавычки: gawk -F'\t' ....

## ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ
Переменная окружения AWKPATH может использоваться для предоставления списка директорий, которые gawk ищет при поиске файлов, указанных с помощью параметров -f, --file, -i и --include, а также директивы @include. Если первоначальный поиск не удался, путь снова ищется после добавления .awk к имени файла.

Переменная окружения AWKLIBPATH может использоваться для предоставления списка директорий, которые gawk ищет при поиске файлов, указанных с помощью параметров -l и --load.

Переменная окружения GAWK_READ_TIMEOUT может использоваться для указания таймаута в миллисекундах для чтения ввода из терминала, канала или двусторонней связи, включая сокеты.

Для подключения к удаленному хосту через сокет, GAWK_SOCK_RETRIES контролирует количество попыток, а GAWK_MSEC_SLEEP — интервал между попытками. Интервал указывается в миллисекундах. На системах, которые не поддерживают usleep(3), значение округляется до целого числа секунд.

Если в окружении существует переменная POSIXLY_CORRECT, то gawk ведет себя точно так же, как если бы на командной строке была указана опция --posix. Если указана опция --lint, gawk выдает предупреждение об этом.

## СТАТУС ВЫХОДА (Exit Code)
Если оператор exit используется с значением, то gawk завершает работу с числовым значением, указанным в нем.

В противном случае, если во время выполнения не возникло проблем, gawk завершает работу со значением константы C EXIT_SUCCESS. Обычно это ноль.

Если произошла ошибка, gawk завершает работу со значением константы C EXIT_FAILURE. Обычно это один.

Если gawk завершает работу из-за фатальной ошибки, статус выхода равен 2. На системах, не соответствующих POSIX, это значение может быть сопоставлено с EXIT_FAILURE.

## ОТЧЕТЫ ОБ ОШИБКАХ
Если вы обнаружите ошибку в gawk, пожалуйста, отправьте электронное письмо на адрес bug-gawk@gnu.org. Пожалуйста, укажите вашу операционную систему и ее версию, версию gawk (из gawk --version), какой компилятор C вы использовали для ее компиляции, а также тестовую программу и данные, которые как можно меньше, чтобы воспроизвести проблему.

Перед отправкой отчета об ошибке, пожалуйста, выполните следующие действия. Во-первых, убедитесь, что у вас последняя версия gawk. Многие ошибки (обычно тонкие) исправляются с каждым релизом, и если ваша версия устарела, проблема может уже быть решена. Во-вторых, проверьте, вызывает ли установка переменной окружения LC_ALL в LC_ALL=C ожидаемое поведение. Если да, это проблема локали, и может быть, что это не ошибка. Наконец, внимательно прочитайте эту страницу руководства и справочное руководство, чтобы убедиться, что то, что вы считаете ошибкой, действительно является ошибкой, а не просто особенностью языка.

Что бы вы ни делали, НИКОГДА не публикуйте отчет об ошибке в comp.lang.awk. Хотя разработчики gawk иногда читают эту новую группу, публикация отчетов об ошибках там является ненадежным способом их сообщения. Вместо этого, пожалуйста, используйте указанные выше адреса электронной почты. Действительно.

Если вы используете систему на базе GNU/Linux или BSD, вы можете отправить отчет об ошибке поставщику вашего дистрибутива. Это нормально, но, пожалуйста, отправьте копию и на официальный адрес электронной почты, так как нет гарантии, что отчет об ошибке будет передан куратору gawk.

## ОШИБКИ
Опция -F не требуется, учитывая функцию присвоения переменных командной строки; она остается только для обратной совместимости.

## СМОТРИТЕ ТАКЖЕ
egrep(1), sed(1), getpid(2), getppid(2), getpgrp(2), getuid(2), geteuid(2), getgid(2), getegid(2), getgroups(2), printf(3), strftime(3), usleep(3)

Язык программирования AWK, Альфред В. Ах, Брайан В. Керниган, Питер Дж. Вайнбергер, Addison-Wesley, 1988. ISBN 0-201-07981-X.

GAWK: Эффективное программирование на AWK, Издание 4.2, поставляется с исходным кодом gawk. Текущая версия этого документа доступна онлайн по адресу https://www.gnu.org/software/gawk/manual.

Документация GNU gettext, доступная онлайн по адресу https://www.gnu.org/software/gettext.

## ПРИМЕРЫ
Вывод и сортировка имен пользователей:
```awk
BEGIN     { FS = ":" }
{ print $1 | "sort" }
```

Подсчет строк в файле:
```awk
{ nlines++ }
END  { print nlines }
```

Предшествование каждой строки ее номером в файле:
```awk
{ print FNR, $0 }
```

Конкатенация и номер строки (вариация на тему):
```awk
{ print NR, $0 }
```

Запуск внешней команды для определенных строк данных:
```bash
tail -f access_log |
awk '/myhome.html/ { system("nmap " $1 ">> logdir/myhome.html") }'
```